/*
 * generated by Xtext 2.38.0
 */
package org.xtext.example.mydsl1.serializer;

import com.google.inject.Inject;
import iDM_DSL.ArithmeticExpr;
import iDM_DSL.BooleanExpr;
import iDM_DSL.Condition;
import iDM_DSL.DSL_IDMPackage;
import iDM_DSL.DistanceSensor;
import iDM_DSL.FunctionCall;
import iDM_DSL.FunctionDeclaration;
import iDM_DSL.IntExpression;
import iDM_DSL.Loop;
import iDM_DSL.Movement;
import iDM_DSL.Program;
import iDM_DSL.ReturnType;
import iDM_DSL.Rotation;
import iDM_DSL.TimeSensors;
import iDM_DSL.VariableAssignement;
import iDM_DSL.VariableDeclaration;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.xtext.example.mydsl1.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DSL_IDMPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DSL_IDMPackage.ARITHMETIC_EXPR:
				sequence_ArithmeticExpr(context, (ArithmeticExpr) semanticObject); 
				return; 
			case DSL_IDMPackage.BOOLEAN:
				sequence_Boolean(context, (iDM_DSL.Boolean) semanticObject); 
				return; 
			case DSL_IDMPackage.BOOLEAN_EXPR:
				sequence_BooleanExpr(context, (BooleanExpr) semanticObject); 
				return; 
			case DSL_IDMPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case DSL_IDMPackage.DISTANCE_SENSOR:
				sequence_DistanceSensor(context, (DistanceSensor) semanticObject); 
				return; 
			case DSL_IDMPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case DSL_IDMPackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case DSL_IDMPackage.INT_EXPRESSION:
				sequence_IntExpression(context, (IntExpression) semanticObject); 
				return; 
			case DSL_IDMPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case DSL_IDMPackage.MOVEMENT:
				sequence_Movement(context, (Movement) semanticObject); 
				return; 
			case DSL_IDMPackage.PARAMETER:
				sequence_Parameter(context, (iDM_DSL.Parameter) semanticObject); 
				return; 
			case DSL_IDMPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case DSL_IDMPackage.RETURN_TYPE:
				sequence_ReturnType(context, (ReturnType) semanticObject); 
				return; 
			case DSL_IDMPackage.ROTATION:
				sequence_Rotation(context, (Rotation) semanticObject); 
				return; 
			case DSL_IDMPackage.TIME_SENSORS:
				sequence_TimeSensors(context, (TimeSensors) semanticObject); 
				return; 
			case DSL_IDMPackage.VARIABLE_ASSIGNEMENT:
				sequence_VariableAssignement(context, (VariableAssignement) semanticObject); 
				return; 
			case DSL_IDMPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ArithmeticExpr
	 *     NumberExpr returns ArithmeticExpr
	 *     ArithmeticExpr returns ArithmeticExpr
	 *
	 * Constraint:
	 *     (operator=Operator? (newvariable+=VariableDeclaration newvariable+=VariableDeclaration*)? left=NumberExpr? right=NumberExpr?)
	 * </pre>
	 */
	protected void sequence_ArithmeticExpr(ISerializationContext context, ArithmeticExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BooleanExpr
	 *     BooleanExpr returns BooleanExpr
	 *
	 * Constraint:
	 *     (operator=BooleanOperator? (newvariable+=VariableDeclaration newvariable+=VariableDeclaration*)? right=Expression? left=Expression?)
	 * </pre>
	 */
	protected void sequence_BooleanExpr(ISerializationContext context, BooleanExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Boolean
	 *     Boolean returns Boolean
	 *
	 * Constraint:
	 *     (value?='value'? (newvariable+=VariableDeclaration newvariable+=VariableDeclaration*)?)
	 * </pre>
	 */
	protected void sequence_Boolean(ISerializationContext context, iDM_DSL.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (then=[Instruction|EString]? else=[Instruction|EString]? (booleanexpr+=BooleanExpr booleanexpr+=BooleanExpr*)?)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns DistanceSensor
	 *     NumberExpr returns DistanceSensor
	 *     DistanceSensor returns DistanceSensor
	 *
	 * Constraint:
	 *     (unit=EString? (newvariable+=VariableDeclaration newvariable+=VariableDeclaration*)?)
	 * </pre>
	 */
	protected void sequence_DistanceSensor(ISerializationContext context, DistanceSensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (functiondeclaration=[FunctionDeclaration|EString]? (parameter+=Parameter parameter+=Parameter*)?)
	 * </pre>
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns FunctionDeclaration
	 *     FunctionDeclaration returns FunctionDeclaration
	 *
	 * Constraint:
	 *     (name=EString (instruction+=Instruction instruction+=Instruction*)? returntype=ReturnType?)
	 * </pre>
	 */
	protected void sequence_FunctionDeclaration(ISerializationContext context, FunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns IntExpression
	 *     NumberExpr returns IntExpression
	 *     IntExpression returns IntExpression
	 *
	 * Constraint:
	 *     (value=EInt? (newvariable+=VariableDeclaration newvariable+=VariableDeclaration*)?)
	 * </pre>
	 */
	protected void sequence_IntExpression(ISerializationContext context, IntExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     ((instruction+=Instruction instruction+=Instruction*)? booleanexpr=BooleanExpr?)
	 * </pre>
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Movement
	 *     Movement returns Movement
	 *
	 * Constraint:
	 *     (direction=Direction? Distance=EInt? unit=EString?)
	 * </pre>
	 */
	protected void sequence_Movement(ISerializationContext context, Movement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=EString type=EString? value=EInt? unit=EString?)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, iDM_DSL.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (instruction+=Instruction instruction+=Instruction*)?
	 * </pre>
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReturnType returns ReturnType
	 *
	 * Constraint:
	 *     returnType=EString?
	 * </pre>
	 */
	protected void sequence_ReturnType(ISerializationContext context, ReturnType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Rotation
	 *     Rotation returns Rotation
	 *
	 * Constraint:
	 *     angleUnit=AngleUnit?
	 * </pre>
	 */
	protected void sequence_Rotation(ISerializationContext context, Rotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns TimeSensors
	 *     NumberExpr returns TimeSensors
	 *     TimeSensors returns TimeSensors
	 *
	 * Constraint:
	 *     (unit=EString? (newvariable+=VariableDeclaration newvariable+=VariableDeclaration*)?)
	 * </pre>
	 */
	protected void sequence_TimeSensors(ISerializationContext context, TimeSensors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns VariableAssignement
	 *     VariableAssignement returns VariableAssignement
	 *
	 * Constraint:
	 *     (variabledeclaration=[VariableDeclaration|EString]? (expression+=Expression expression+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_VariableAssignement(ISerializationContext context, VariableAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (name=EString type=EString? (expression+=Expression expression+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
